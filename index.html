<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MTG Proxy Generator</title>
    <script src="https://unpkg.com/react@18/umd/react.development.js" crossorigin></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js" crossorigin></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        /* --- Theme Variables --- */
        :root {
            --bg-primary: #111827;
            --bg-secondary: #1f2937;
            --bg-tertiary: #374151;
            --text-primary: #f9fafb;
            --text-secondary: #d1d5db;
            --text-muted: #9ca3af;
            --accent-primary: #a855f7; /* A nice medium purple */
            --accent-primary-dark: #6b21a8; /* A darker shade of purple */
            --accent-primary-light: #d8b4fe; /* A lighter shade of purple */
            --border-color: #4b5563;
            --error-bg: #450a0a;
            --error-border: #b91c1c;
            --error-text: #fca5a5;
            --success-bg: #166534;
            --success-border: #16a34a;
            --success-text: #bbfa9f;
            --warning-bg: #422006; /* Dark Orange */
            --warning-border: #d97706; /* Amber */
            --warning-text: #fde68a; /* Light Yellow */
            --shadow-sm: 0 1px 2px 0 rgb(0 0 0 / 0.05);
            --shadow-md: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
            --border-radius-sm: 0.25rem; /* 4px */
            --border-radius-md: 0.375rem; /* 6px */
            --border-radius-lg: 0.5rem; /* 8px */
            --border-radius-full: 9999px;
        }

        /* Basic reset and font */
        body {
            font-family: 'Inter', sans-serif;
            margin: 0;
            background-color: var(--bg-primary);
            color: var(--text-primary);
            line-height: 1.5;
        }

        /* Utility classes (simulating Tailwind) */
        .bg-primary { background-color: var(--bg-primary); }
        .bg-secondary { background-color: var(--bg-secondary); }
        .bg-tertiary { background-color: var(--bg-tertiary); }
        .text-primary { color: var(--text-primary); }
        .text-secondary { color: var(--text-secondary); }
        .text-muted { color: var(--text-muted); }
        .text-accent { color: var(--accent-primary); }
        .text-2xl { font-size: 1.5rem; line-height: 2rem; }
        .text-lg { font-size: 1.125rem; line-height: 1.75rem; }
        .text-sm { font-size: 0.875rem; line-height: 1.25rem; }
        .font-semibold { font-weight: 600; }
        .font-medium { font-weight: 500; }
        .mb-1 { margin-bottom: 0.25rem; }
        .mb-2 { margin-bottom: 0.5rem; }
        .mb-4 { margin-bottom: 1rem; }
        .mb-6 { margin-bottom: 1.5rem; }
        .mt-4 { margin-top: 1rem; }
        .mt-6 { margin-top: 1.5rem; }
        .ml-2 { margin-left: 0.5rem; }
        .mr-2 { margin-right: 0.5rem; }
        .w-full { width: 100%; }
        .max-w-md { max-width: 28rem; }
        .max-w-2xl { max-width: 42rem; }
        .mx-auto { margin-left: auto; margin-right: auto; }
        .p-2 { padding: 0.5rem; }
        .p-3 { padding: 0.75rem; }
        .p-4 { padding: 1rem; }
        .p-6 { padding: 1.5rem; }
        .px-4 { padding-left: 1rem; padding-right: 1rem; }
        .py-2 { padding-top: 0.5rem; padding-bottom: 0.5rem; }
        .py-3 { padding-top: 0.75rem; padding-bottom: 0.75rem; }
        .border { border-width: 1px; border-style: solid; border-color: var(--border-color); }
        .border-accent { border-color: var(--accent-primary); }
        .rounded-sm { border-radius: var(--border-radius-sm); }
        .rounded-md { border-radius: var(--border-radius-md); }
        .rounded-lg { border-radius: var(--border-radius-lg); }
        .rounded-full { border-radius: var(--border-radius-full); }
        .shadow-md { box-shadow: var(--shadow-md); }
        .shadow-lg { box-shadow: var(--shadow-lg); }
        .resize-none { resize: none; }
        .min-h-\[150px\] { min-height: 150px; }
        .transition-all { transition-property: all; transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1); transition-duration: 200ms; }
        .focus\:ring { outline: 2px solid transparent; outline-offset: 2px; box-shadow: 0 0 0 3px var(--accent-primary-light); }
        .flex { display: flex; }
        .flex-col { flex-direction: column; }
        .items-center { align-items: center; }
        .justify-center { justify-content: center; }
        .flex-grow { flex-grow: 1; }
        .relative { position: relative; }
        .absolute { position: absolute; }
        .top-full { top: 100%; }
        .right-0 { right: 0; }
        .z-10 { z-index: 10; }
        .list-disc { list-style-type: disc; }
        .list-inside { list-style-position: inside; }
        .whitespace-pre-wrap { white-space: pre-wrap; }
        .opacity-50 { opacity: 0.5; }
        .cursor-pointer { cursor: pointer; }
        .cursor-not-allowed { cursor: not-allowed; }
        .min-h-screen { min-height: 100vh; }
        .h-6 { height: 1.5rem; }
        .w-6 { width: 1.5rem; }
        .h-3 { height: 0.75rem; }

        /* --- Component Specific Styles --- */

        /* Text Area */
        .custom-textarea {
            background-color: var(--bg-secondary);
            border: 1px solid var(--border-color);
            color: var(--text-primary);
            border-radius: var(--border-radius-md);
            padding: 0.75rem;
            min-height: 150px;
            transition: border-color 0.2s ease-in-out, box-shadow 0.2s ease-in-out;
        }
        .custom-textarea:focus {
            outline: none;
            border-color: var(--accent-primary);
            box-shadow: 0 0 0 3px rgba(168, 85, 247, 0.4); /* Purple focus ring */
        }
        .custom-textarea::placeholder {
            color: var(--text-muted);
        }

        /* Progress Bar */
        .progress-container {
            background-color: var(--bg-tertiary);
            border-radius: var(--border-radius-full);
            overflow: hidden;
        }
        .progress-bar {
            background-color: var(--accent-primary);
            height: 100%;
            border-radius: var(--border-radius-full);
            transition: width 0.4s ease;
        }

        /* Button */
        .custom-button {
            background-color: var(--accent-primary);
            color: var(--bg-primary);
            border: 2px solid transparent;
            padding: 0.75rem 1.5rem;
            border-radius: var(--border-radius-lg);
            font-weight: 600;
            transition: all 0.2s ease-in-out;
            box-shadow: var(--shadow-sm);
            cursor: pointer;
        }
        .custom-button:hover:not(:disabled) {
            background-color: var(--accent-primary-light);
            box-shadow: var(--shadow-md);
            transform: translateY(-1px);
        }
        .custom-button:focus {
            outline: none;
            box-shadow: 0 0 0 4px rgba(168, 85, 247, 0.4); /* Purple Focus ring */
        }
        .custom-button:active:not(:disabled) {
            background-color: var(--accent-primary-dark);
            transform: translateY(0px);
            box-shadow: var(--shadow-sm);
        }
        .custom-button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            box-shadow: none;
        }

        /* Info Icon & Tooltip */
        .info-icon {
            color: var(--text-muted);
            transition: color 0.2s ease;
        }
        .info-icon:hover {
            color: var(--text-primary);
        }
        .tooltip {
            background-color: var(--bg-secondary);
            border: 1px solid var(--border-color);
            color: var(--text-secondary);
            border-radius: var(--border-radius-md);
            box-shadow: var(--shadow-lg);
            width: 22rem; /* Increased width */
            padding: 0.75rem; /* p-3 */
            margin-top: 0.5rem; /* mt-2 */
        }
        .tooltip p, .tooltip ul {
            margin-bottom: 0.5rem;
        }
        .tooltip ul {
            padding-left: 1.25rem; /* Indent list */
        }
        .tooltip li {
            margin-bottom: 0.25rem;
        }

        /* Status Message Area (Combined Error/Warning/Success) */
        .status-message-container {
             margin-top: 1rem; /* mt-4 */
             max-width: 28rem; /* max-w-md */
             width: 100%;
        }
        .status-message {
            border-radius: var(--border-radius-md);
            padding: 0.75rem; /* p-3 */
            margin-bottom: 0.5rem; /* Space between multiple messages */
            white-space: pre-wrap;
            font-size: 0.875rem; /* text-sm */
        }
        .status-message.error {
            background-color: var(--error-bg);
            border: 1px solid var(--error-border);
            color: var(--error-text);
        }
         .status-message.warning {
            background-color: var(--warning-bg);
            border: 1px solid var(--warning-border);
            color: var(--warning-text);
        }
         .status-message.success { /* For PDF build notification */
            background-color: var(--success-bg);
            border: 1px solid var(--success-border);
            color: var(--success-text);
         }
        .status-message strong {
            color: var(--text-primary); /* Make prefix stand out */
            display: block; /* Ensure prefix is on its own line */
            margin-bottom: 0.25rem;
        }

        /* Separator */
        .separator {
            border-color: var(--bg-tertiary); /* Subtle separator */
        }

    </style>
</head>
<body class="bg-primary">
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useRef, useEffect } = React;
        const { createRoot } = ReactDOM;

        const MTGProxyGenerator = () => {
            // --- State and Refs ---
            const [showInfoDiv, setShowInfoDiv] = useState(false);
            const timeoutRef = useRef(null);
            const textAreaRef = useRef(null);
            const progressBarRef = useRef(null);
            const progressPercentageRef = useRef(null);
            const [isGenerating, setIsGenerating] = useState(false);
            const [statusMessages, setStatusMessages] = useState([]); // { type: 'error'|'warning'|'success', message: string }[]
            const [pdfBuildNotificationVisible, setPdfBuildNotificationVisible] = useState(false);

            // --- Effects ---
            useEffect(() => {
                return () => {
                    if (timeoutRef.current) {
                        clearTimeout(timeoutRef.current);
                    }
                };
            }, []);

             // --- Helper: Add Status Message ---
            const addStatusMessage = (type, message) => {
                setStatusMessages(prev => [...prev, { type, message }]);
            };

            // --- Event Handlers ---
            const handleInfoMouseEnter = () => {
                if (timeoutRef.current) clearTimeout(timeoutRef.current);
                timeoutRef.current = setTimeout(() => {
                    setShowInfoDiv(true);
                }, 200);
            };

            const handleInfoMouseLeave = () => {
                if (timeoutRef.current) clearTimeout(timeoutRef.current);
                setShowInfoDiv(false);
            };

            // --- Helper Functions ---

            // Helper to get image URIs from Scryfall data (handles single and double faced)
            const getImageUris = (cardData) => {
                const uris = [];
                if (cardData?.card_faces) {
                     cardData.card_faces.forEach(face => {
                        if(face?.image_uris?.png) uris.push(face.image_uris.png);
                        else if(face?.image_uris?.large) uris.push(face.image_uris.large);
                        else if(face?.image_uris?.normal) uris.push(face.image_uris.normal);
                    });
                } else {
                    if (cardData?.image_uris?.png) uris.push(cardData.image_uris.png);
                    else if (cardData?.image_uris?.large) uris.push(cardData.image_uris.large);
                    else if (cardData?.image_uris?.normal) uris.push(cardData.image_uris.normal);
                }
                 // Filter out potential undefined entries if no image exists for a face
                return uris.filter(url => url);
            };

             // Helper: Safely fetch JSON from a URL
            const safeFetchJson = async (url, context) => {
                 try {
                    const response = await fetch(url);
                    if (!response.ok) {
                        const errorBody = await response.text(); // Try to get more details
                        console.error(`Scryfall API Error (${context}): ${response.status} ${response.statusText} for ${url}`, errorBody);
                        // Try parsing Scryfall's error JSON if possible
                        try {
                           const errJson = JSON.parse(errorBody);
                           if(errJson.details) throw new Error(`${response.status} ${response.statusText}: ${errJson.details}`);
                        } catch (parseError) { /* Ignore if error body isn't JSON */ }
                         // Generic error if parsing failed or no details
                        throw new Error(`${response.status} ${response.statusText}`);
                    }
                    return await response.json();
                 } catch (error) {
                     // Catch fetch errors (network issues) and re-throw with context
                     console.error(`Network or fetch error (${context}) for ${url}:`, error);
                     throw new Error(`Network error during ${context}: ${error.message}`);
                 }
             };


            // Fetch card image URL(s) from Scryfall API
            const fetchCardImage = async (cardName, setCode = null, collectorNumber = null, originalInput = "") => {
                let specificPrintFailed = false;
                let fallbackNote = null;
                let foundData = null; // To store card data if found

                 // --- Priority 1: Specific Set + Collector Number ---
                if (setCode && collectorNumber) {
                    const specificUrl = `https://api.scryfall.com/cards/${encodeURIComponent(setCode.toLowerCase())}/${encodeURIComponent(collectorNumber)}`;
                    try {
                        console.log(`Attempting fetch specific print: ${originalInput} at ${specificUrl}`);
                        foundData = await safeFetchJson(specificUrl, `Specific Print ${setCode}/${collectorNumber}`);
                        const uris = getImageUris(foundData);
                        if (uris.length > 0) {
                            console.log(`Found specific print: ${foundData.name} (${foundData.set.toUpperCase()}, ${foundData.collector_number})`);
                            return { uris, fallbackNote: null }; // Success
                        } else {
                             throw new Error(`No image URIs found for ${setCode}/${collectorNumber}, though card data exists.`);
                        }
                    } catch (error) {
                        console.warn(`Specific print fetch (${setCode}/${collectorNumber}) failed for "${originalInput}": ${error.message}. Falling back to name search.`);
                        specificPrintFailed = true;
                        fallbackNote = `Specific print (${setCode}/${collectorNumber}) not found or lacks image.`;
                        // Don't return yet, fall through to name/set search
                    }
                }

                 // --- Priority 2: Search by Name (and potentially filter by Set Code if provided without Number) ---
                let baseCardData = null;
                let printsSearchUri = null;

                // Try Exact Name first
                try {
                    console.log(`Attempting exact name match for: "${cardName}" (related to input: "${originalInput}")`);
                    const exactUrl = `https://api.scryfall.com/cards/named?exact=${encodeURIComponent(cardName)}`;
                    baseCardData = await safeFetchJson(exactUrl, `Exact Name "${cardName}"`);
                    printsSearchUri = baseCardData?.prints_search_uri; // Get prints URI if successful
                } catch (error) {
                     // Only log non-404 errors here, 404 is expected if exact match fails
                    if (!error.message.includes("404")) {
                        console.warn(`Exact name match failed unexpectedly for "${cardName}": ${error.message}`);
                    }
                    // Continue to fuzzy search
                }

                 // Try Fuzzy Name if Exact failed or didn't yield data
                if (!baseCardData) {
                    try {
                        console.log(`Attempting fuzzy name match for: "${cardName}" (related to input: "${originalInput}")`);
                        const fuzzyUrl = `https://api.scryfall.com/cards/named?fuzzy=${encodeURIComponent(cardName)}`;
                        baseCardData = await safeFetchJson(fuzzyUrl, `Fuzzy Name "${cardName}"`);
                         printsSearchUri = baseCardData?.prints_search_uri;
                    } catch (error) {
                        // If fuzzy also fails, this is likely a fatal error for this card lookup
                        console.error(`Fuzzy name match failed for "${cardName}": ${error.message}`);
                        // Combine specific print failure note if applicable
                        const message = specificPrintFailed
                            ? `${fallbackNote} Additionally, failed to find card by name "${cardName}".`
                            : `Failed to find card "${cardName}" by exact or fuzzy match: ${error.message}`;
                         throw new Error(message);
                    }
                }

                 // --- Priority 2b: Filter Prints by Set Code (if setCode provided WITHOUT collectorNumber) ---
                if (setCode && !collectorNumber && printsSearchUri) {
                     try {
                        console.log(`Fetching prints for "${baseCardData.name}" from ${printsSearchUri} to find set "${setCode}"`);
                        const printsData = await safeFetchJson(printsSearchUri, `Prints Search for "${baseCardData.name}"`);

                        // Find the first print matching the set code (case-insensitive)
                        const matchedPrint = printsData?.data?.find(
                            print => print.set.toLowerCase() === setCode.toLowerCase()
                        );

                        if (matchedPrint) {
                            console.log(`Found print in set "${setCode}": ${matchedPrint.name} (${matchedPrint.set.toUpperCase()}, ${matchedPrint.collector_number})`);
                            foundData = matchedPrint; // Use this specific print's data
                            const uris = getImageUris(foundData);
                            if (uris.length > 0) {
                                return { uris, fallbackNote: null }; // Success! Found by set code only.
                            } else {
                                // Found print but no image, this is strange. Fallback.
                                console.warn(`Found print for ${cardName} in set ${setCode}, but it has no image URI. Falling back.`);
                                if (!fallbackNote) fallbackNote = ""; // Ensure fallbackNote exists
                                fallbackNote += ` Print in set ${setCode} found but lacks image.`;
                                specificPrintFailed = true; // Mark as failed to force using the base card image
                            }
                        } else {
                            console.warn(`Could not find print for "${cardName}" in set "${setCode}". Falling back to default print.`);
                             if (!fallbackNote) fallbackNote = "";
                            fallbackNote += ` Print in set "${setCode}" not found.`;
                            specificPrintFailed = true; // Mark as failed to force using the base card image
                        }
                     } catch (error) {
                         console.warn(`Error fetching or processing prints for "${cardName}" (Set: ${setCode}): ${error.message}. Falling back.`);
                         if (!fallbackNote) fallbackNote = "";
                         fallbackNote += ` Error searching prints for set "${setCode}".`;
                         specificPrintFailed = true;
                     }
                 }

                 // --- Priority 3: Use Base Card Data (from Name search or if Set search failed/wasn't applicable) ---
                if (baseCardData && !foundData) { // Only use if we haven't already found a specific print
                    foundData = baseCardData; // Use the data found via name search
                    console.log(`Using image for "${foundData.name}" (default print or fallback). Set: ${foundData.set.toUpperCase()}, Number: ${foundData.collector_number}`);
                    if (specificPrintFailed && !fallbackNote?.includes("Falling back")) {
                        // Add specific fallback message if not already present
                        fallbackNote += ` Falling back to default print: ${foundData.name} (${foundData.set.toUpperCase()}, ${foundData.collector_number}).`;
                    }
                 }

                 // --- Final Result ---
                if (foundData) {
                    const uris = getImageUris(foundData);
                    if (uris.length > 0) {
                        return { uris, fallbackNote };
                    } else {
                         // If we got here, even the fallback card has no image
                        const message = `Found card data for "${foundData.name}" but no suitable image URI was available.`;
                        console.error(message);
                        throw new Error(message);
                    }
                } else {
                    // Should ideally be caught earlier, but as a safeguard
                    const message = specificPrintFailed
                        ? `${fallbackNote} And ultimately could not resolve to any card image for "${originalInput}".`
                        : `Could not resolve "${originalInput}" to any card image.`;
                     throw new Error(message);
                }


                 // --- Handle "Random" --- (Should be parsed in handleGenerate now)
                 // Keeping this structure just in case, but it shouldn't be reached if parsing is correct.
                // if (cardName.toLowerCase() === 'random') { ... }
            };


            // --- PDF Generation ---
            const handleGenerate = async () => {
                if (!textAreaRef.current) return;

                const rawLines = textAreaRef.current.value
                    .split('\n')
                    .map(line => line.trim())
                    .filter(line => line !== '');

                if (rawLines.length === 0) {
                    setStatusMessages([{ type: 'error', message: 'Please enter at least one card name.' }]);
                    return;
                }

                setIsGenerating(true);
                setStatusMessages([]); // Clear previous messages
                setPdfBuildNotificationVisible(false);
                let processedLineCount = 0;
                const totalLines = rawLines.length;

                if (progressBarRef.current && progressPercentageRef.current) {
                    progressBarRef.current.style.width = '0%';
                    progressPercentageRef.current.textContent = '0%';
                }

                const loadJsPDF = () => new Promise((resolve, reject) => {
                    // ... (jsPDF loading logic - unchanged) ...
                    if (typeof window === 'undefined') return reject(new Error('Not in browser'));
                    if (typeof window.jspdf?.jsPDF !== 'undefined') return resolve(window.jspdf.jsPDF);
                    const script = document.createElement('script');
                    script.src = 'https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js';
                    script.async = true;
                    script.onload = () => typeof window.jspdf?.jsPDF !== 'undefined' ? resolve(window.jspdf.jsPDF) : reject(new Error('jsPDF loaded but constructor not found.'));
                    script.onerror = () => reject(new Error('Failed to load jsPDF script.'));
                    document.head.appendChild(script);
                });

                try {
                    const cardFetchPromises = [];

                    // 1. Parse Input and Initiate Fetches
                    for (const line of rawLines) {
                        let remainingLine = line;
                        let cardName = "";
                        let quantity = 1;
                        let setCode = null;
                        let collectorNumber = null;
                        let isRandom = false;

                        // A. Check for specific print format: (SET, NUM) or (SET) at the end
                        const printMatchFull = remainingLine.match(/^(.*?)\s*\(([^,]+?)\s*,\s*([^)]+?)\)\s*$/i);
                        const printMatchSetOnly = remainingLine.match(/^(.*?)\s*\(([^),]+?)\)\s*$/i); // Ensure no comma inside for set-only

                        if (printMatchFull) {
                            remainingLine = printMatchFull[1].trim();
                            setCode = printMatchFull[2].trim();
                            collectorNumber = printMatchFull[3].trim();
                             console.log(`Parsed Set/Num: [${setCode}, ${collectorNumber}] from "${line}"`);
                        } else if (printMatchSetOnly) {
                            remainingLine = printMatchSetOnly[1].trim();
                            setCode = printMatchSetOnly[2].trim();
                            collectorNumber = null; // Explicitly null
                            console.log(`Parsed Set Only: [${setCode}] from "${line}"`);
                        } else {
                             // No set/number info in parentheses found
                             remainingLine = line.trim(); // Use the original line for further parsing
                        }


                        // B. Check for quantity: [num] [name] or [name] [x][num] on the remaining string
                        const quantityMatch = remainingLine.match(/^(?:(\d+)\s*x?\s*(.+?)|(.+?)\s*x?(\d+))\s*$/i);
                        if (quantityMatch) {
                            quantity = parseInt(quantityMatch[1] || quantityMatch[4], 10);
                            cardName = (quantityMatch[2] || quantityMatch[3]).trim();
                        } else {
                            cardName = remainingLine.trim(); // Use the remaining string as the name if no quantity
                        }

                        if (isNaN(quantity) || quantity < 1) quantity = 1;

                        // C. Handle "Random" keyword (overrides parsed name)
                        if (cardName.toLowerCase() === 'random') {
                             isRandom = true;
                             cardName = 'Random'; // Standardize
                             setCode = null; // Random cannot have set/number
                             collectorNumber = null;
                        }

                        console.log(`Processing Line: "${line}" -> Name: "${cardName}", Qty: ${quantity}, Set: ${setCode}, Num: ${collectorNumber}, Random: ${isRandom}`);


                         // D. Add fetch promise
                         if (isRandom) {
                              // Handle random card fetching directly
                              cardFetchPromises.push(
                                 (async () => {
                                     try {
                                         const randomUrl = 'https://api.scryfall.com/cards/random';
                                         const data = await safeFetchJson(randomUrl, 'Random Card');
                                         const uris = getImageUris(data);
                                         if (uris.length === 0) throw new Error("Random card found but has no image URI.");
                                         return uris.map(url => ({ url, quantity, originalInput: line }));
                                     } catch (error) {
                                         addStatusMessage('error', `Failed to fetch random card for line "${line}": ${error.message}`);
                                         return [];
                                     } finally {
                                        processedLineCount++;
                                        // Update progress (moved inside specific promise resolution)
                                        if (progressBarRef.current && progressPercentageRef.current) {
                                            const percentage = Math.round((processedLineCount / totalLines) * 100);
                                            progressBarRef.current.style.width = `${percentage}%`;
                                            progressPercentageRef.current.textContent = `${percentage}%`;
                                        }
                                     }
                                 })()
                             );

                         } else if (cardName) { // Only fetch if a card name exists
                             cardFetchPromises.push(
                                fetchCardImage(cardName, setCode, collectorNumber, line)
                                    .then(result => {
                                        if (result.fallbackNote) {
                                            addStatusMessage('warning', `For "${line}": ${result.fallbackNote}`);
                                        }
                                        return result.uris.map(url => ({ url, quantity, originalInput: line }));
                                    })
                                    .catch(error => {
                                        addStatusMessage('error', `Error for "${line}": ${error.message}`);
                                        return []; // Return empty array on error
                                    })
                                     .finally(() => {
                                        processedLineCount++;
                                        // Update progress (moved inside specific promise resolution)
                                        if (progressBarRef.current && progressPercentageRef.current) {
                                            const percentage = Math.round((processedLineCount / totalLines) * 100);
                                            progressBarRef.current.style.width = `${percentage}%`;
                                            progressPercentageRef.current.textContent = `${percentage}%`;
                                        }
                                    })
                             );
                         } else {
                             // Handle cases where parsing resulted in no card name (should be rare)
                            addStatusMessage('warning', `Could not parse a card name from line: "${line}"`);
                            processedLineCount++; // Still count it as processed
                             if (progressBarRef.current && progressPercentageRef.current) {
                                const percentage = Math.round((processedLineCount / totalLines) * 100);
                                progressBarRef.current.style.width = `${percentage}%`;
                                progressPercentageRef.current.textContent = `${percentage}%`;
                            }
                         }

                    } // End parsing loop

                    // 2. Await all fetches and collect results
                    const results = await Promise.all(cardFetchPromises);
                    const cardData = results.flat(); // Flatten the array of arrays [{url, quantity, originalInput}, ...]

                    // Check if any cards were successfully fetched before proceeding
                    if (cardData.length === 0) {
                        addStatusMessage('error', `No card images could be successfully fetched or added.${statusMessages.some(m => m.type === 'error') ? ' See errors above.' : ''}`);
                        setIsGenerating(false);
                        return;
                    }

                    // Set PDF building notification
                    setPdfBuildNotificationVisible(true);
                    // Brief delay to allow UI update before heavy PDF work
                    await new Promise(resolve => setTimeout(resolve, 100));

                    // 3. Load jsPDF and initialize document
                    const jsPDF = await loadJsPDF();
                    const doc = new jsPDF({ orientation: 'portrait', unit: 'in', format: 'letter' });

                    // --- PDF Layout Constants ---
                    // ... (Layout constants - unchanged) ...
                    const mmToIn = (mm) => mm / 25.4;
                    const cardWidthIn = 2.5;
                    const cardHeightIn = 3.5;
                    const cardsPerRow = 3;
                    const cardsPerCol = 3;
                    const totalCardsPerPage = cardsPerRow * cardsPerCol;
                    const pageW = doc.internal.pageSize.getWidth(); // 8.5 in
                    const pageH = doc.internal.pageSize.getHeight(); // 11 in
                    const marginIn = mmToIn(3); // ~0.12 in
                    const gapIn = mmToIn(3);     // ~0.12 in
                    const requiredWidth = marginIn * 2 + cardsPerRow * cardWidthIn + (cardsPerRow - 1) * gapIn;
                    const requiredHeight = marginIn * 2 + cardsPerCol * cardHeightIn + (cardsPerCol - 1) * gapIn;

                    if (requiredWidth > pageW || requiredHeight > pageH) {
                        console.warn("Calculated layout might exceed page size. Consider smaller margins/gaps or fewer cards per page.");
                        addStatusMessage('warning', "Card layout might slightly exceed page boundaries due to minimal margins/gaps.");
                    }

                    let currentX = marginIn;
                    let currentY = marginIn;
                    let cardsOnCurrentPage = 0;
                    let totalCardsAddedToPdf = 0;
                    let imageAddErrors = 0;

                    // 4. Add Images to PDF
                    for (const card of cardData) {
                         for (let j = 0; j < card.quantity; j++) {
                            if (cardsOnCurrentPage >= totalCardsPerPage) {
                                doc.addPage();
                                currentX = marginIn;
                                currentY = marginIn;
                                cardsOnCurrentPage = 0;
                            }

                             try {
                                // Fetch image data as Blob
                                const imageResponse = await fetch(card.url);
                                if (!imageResponse.ok) throw new Error(`HTTP ${imageResponse.status} fetching image data`);
                                const imageBlob = await imageResponse.blob();

                                // Convert Blob to Data URL
                                const imageDataUrl = await new Promise((resolve, reject) => {
                                    const reader = new FileReader();
                                    reader.onloadend = () => resolve(reader.result);
                                    reader.onerror = (err) => reject(new Error("FileReader error: " + err));
                                    reader.readAsDataURL(imageBlob);
                                });

                                // Determine image type (more robustly)
                                const imageType = imageBlob.type.split('/')[1]?.toUpperCase() || (card.url.toUpperCase().includes('PNG') ? 'PNG' : 'JPEG');

                                doc.addImage(imageDataUrl, imageType, currentX, currentY, cardWidthIn, cardHeightIn);
                                cardsOnCurrentPage++;
                                totalCardsAddedToPdf++;

                                // Move to next position
                                currentX += cardWidthIn + gapIn;
                                if (cardsOnCurrentPage % cardsPerRow === 0) {
                                    currentX = marginIn;
                                    currentY += cardHeightIn + gapIn;
                                }
                             } catch (error) {
                                imageAddErrors++;
                                console.error(`Error adding image ${card.url} (from input "${card.originalInput}") to PDF:`, error);
                                addStatusMessage('error', `Error adding image for "${card.originalInput}" to PDF: ${error.message}`);
                                // Skip this card instance, but continue trying others
                            }
                        } // end quantity loop
                    } // end cardData loop

                    // 5. Finalize and Save
                    setPdfBuildNotificationVisible(false); // Hide build notification

                    if (totalCardsAddedToPdf > 0) {
                        doc.save('mtg-proxies.pdf');
                        addStatusMessage('success', `Successfully generated PDF with ${totalCardsAddedToPdf} card images.`);
                        if(imageAddErrors > 0) {
                             addStatusMessage('warning', `${imageAddErrors} image(s) failed to be added to the PDF. See errors above.`);
                        }
                    } else {
                         addStatusMessage('error', `No cards were ultimately added to the PDF.${statusMessages.some(m => m.type === 'error' || m.type === 'warning') ? ' Check messages above.' : ''}`);
                    }

                } catch (error) {
                    console.error("Fatal PDF Generation Error:", error);
                    // Add as a new error message, preserving others
                     addStatusMessage('error', `Fatal Error during PDF generation: ${error.message}`);
                } finally {
                    setIsGenerating(false);
                    setPdfBuildNotificationVisible(false); // Ensure it's hidden on any exit
                }
            }; // End handleGenerate

            // --- Render JSX ---
            return (
                <div className="min-h-screen bg-primary flex flex-col items-center p-4 md:p-6 font-sans w-full">
                    <div className="w-full max-w-2xl mx-auto flex flex-col items-center">

                        <h1 className="text-2xl font-semibold text-primary mb-6 mt-4">
                            MTG Proxy Generator
                        </h1>

                        <textarea
                            className="w-full max-w-md custom-textarea mb-4 resize-none"
                            placeholder={
`Enter card names, one per line...
Examples:
4 Sol Ring
Island x8
Ragavan, Nimble Pilferer
Black Lotus (LEA, 232)  <-- Set Code, Number
2 Forest (UST)          <-- Set Code Only
Random x5               <-- Random Card`
                            }
                            ref={textAreaRef}
                            disabled={isGenerating}
                            rows="8"
                        />

                        {/* Progress Bar & Status Area */}
                        <div className="w-full max-w-md mb-4">
                            <div className="flex items-center px-1">
                                <div className="progress-container flex-grow h-3 mr-2">
                                    <div
                                        className="progress-bar"
                                        style={{ width: '0%' }}
                                        ref={progressBarRef}
                                    />
                                </div>
                                <span className="text-secondary text-sm font-medium" ref={progressPercentageRef}>
                                    0%
                                </span>
                            </div>
                         </div>

                         {/* Status Messages Area */}
                        <div className="status-message-container w-full max-w-md mb-6">
                             {pdfBuildNotificationVisible && (
                                <div className="status-message success">
                                    <strong>Building PDF...</strong>
                                    This might take a moment, especially for many high-resolution images.
                                </div>
                            )}
                            {statusMessages.map((msg, index) => (
                                <div key={index} className={`status-message ${msg.type}`}>
                                    <strong>{msg.type.charAt(0).toUpperCase() + msg.type.slice(1)}:</strong>
                                    {msg.message}
                                </div>
                            ))}
                        </div>

                        <hr className="w-full max-w-md separator mb-6" />

                        {/* Button and Info Section */}
                        <div className="w-full max-w-md flex items-center justify-center mb-6">
                            <button
                                className="custom-button mr-2"
                                onClick={handleGenerate}
                                disabled={isGenerating}
                            >
                                {isGenerating ? 'Generating...' : 'Generate Proxies'}
                            </button>

                            <div
                                className="relative cursor-pointer ml-2"
                                onMouseEnter={handleInfoMouseEnter}
                                onMouseLeave={handleInfoMouseLeave}
                            >
                                <svg xmlns="http://www.w3.org/2000/svg" className="h-6 w-6 info-icon" fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth={2}>
                                    <path strokeLinecap="round" strokeLinejoin="round" d="M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
                                </svg>
                                {showInfoDiv && (
                                    <div className="absolute tooltip z-10" style={{ top: '100%', right: 0 }}>
                                        <p className="font-semibold text-primary mb-1">Input Format:</p>
                                        <p className="mb-2">
                                            Enter one card per line. Specify quantities like "4 Card Name", "Card Name x4", or "Card Name 4".
                                            Use "Random" for a random card. Fuzzy matching used if exact name fails.
                                        </p>
                                         <p className="font-semibold text-primary mb-1">Specify Print:</p>
                                        <p className="mb-2">
                                            Add the <strong className="text-accent">Set Code</strong> (e.g., LEA, MH2, SLD) and optionally the <strong className="text-accent">Collector Number</strong> in parentheses at the end of the line.
                                        </p>
                                        <ul className="list-disc list-inside mb-2">
                                            <li>`Card Name (SET, NUM)` - Specific print</li>
                                            <li>`Card Name (SET)` - Any print from that set</li>
                                        </ul>
                                         <p className="mb-2">
                                            If a specific print isn't found or lacks an image, the generator will try to fall back to a default print of the card.
                                        </p>
                                        <p className="font-semibold text-primary mb-1">Examples:</p>
                                        <ul className="list-disc list-inside">
                                            <li>Black Lotus</li>
                                            <li>4 Sol Ring</li>
                                            <li>Mountain x8</li>
                                            <li>Island 6</li>
                                            <li>Black Lotus (Vintage Campionship, 2017NA)</li>
                                            <li>Random x5</li>
                                        </ul>
                                    </div>
                                )}
                            </div>
                        </div>
                    </div>
                </div>
            );
        }; // End of MTGProxyGenerator component

        // --- React App Initialization ---
        const rootElement = document.getElementById('root');
        const root = createRoot(rootElement);
        root.render(<MTGProxyGenerator />);

    </script>
</body>
</html>
