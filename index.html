<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MTG Proxy Generator</title>
    <script src="https://unpkg.com/react@18/umd/react.development.js" crossorigin></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js" crossorigin></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        /* --- Theme Variables --- */
        :root {
            --bg-primary: #111827;
            --bg-secondary: #1f2937;
            --bg-tertiary: #374151;
            --text-primary: #f9fafb;
            --text-secondary: #d1d5db;
            --text-muted: #9ca3af;
            --accent-primary: #a855f7; /* A nice medium purple */
            --accent-primary-dark: #6b21a8; /* A darker shade of purple */
            --accent-primary-light: #d8b4fe; /* A lighter shade of purple */
            --border-color: #4b5563;
            --error-bg: #450a0a;
            --error-border: #b91c1c;
            --error-text: #fca5a5;
            --success-bg: #166534;
            --success-border: #16a34a;
            --success-text: #bbfa9f;
            --shadow-sm: 0 1px 2px 0 rgb(0 0 0 / 0.05);
            --shadow-md: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
            --border-radius-sm: 0.25rem; /* 4px */
            --border-radius-md: 0.375rem; /* 6px */
            --border-radius-lg: 0.5rem; /* 8px */
            --border-radius-full: 9999px;
        }

        /* Basic reset and font */
        body {
            font-family: 'Inter', sans-serif;
            margin: 0;
            background-color: var(--bg-primary);
            color: var(--text-primary);
            line-height: 1.5;
        }

        /* Utility classes (simulating Tailwind) */
        .bg-primary { background-color: var(--bg-primary); }
        .bg-secondary { background-color: var(--bg-secondary); }
        .bg-tertiary { background-color: var(--bg-tertiary); }
        .text-primary { color: var(--text-primary); }
        .text-secondary { color: var(--text-secondary); }
        .text-muted { color: var(--text-muted); }
        .text-accent { color: var(--accent-primary); }
        .text-2xl { font-size: 1.5rem; line-height: 2rem; }
        .text-lg { font-size: 1.125rem; line-height: 1.75rem; }
        .text-sm { font-size: 0.875rem; line-height: 1.25rem; }
        .font-semibold { font-weight: 600; }
        .font-medium { font-weight: 500; }
        .mb-1 { margin-bottom: 0.25rem; }
        .mb-2 { margin-bottom: 0.5rem; }
        .mb-4 { margin-bottom: 1rem; }
        .mb-6 { margin-bottom: 1.5rem; }
        .mt-4 { margin-top: 1rem; }
        .mt-6 { margin-top: 1.5rem; }
        .ml-2 { margin-left: 0.5rem; }
        .mr-2 { margin-right: 0.5rem; }
        .w-full { width: 100%; }
        .max-w-md { max-width: 28rem; }
        .max-w-2xl { max-width: 42rem; }
        .mx-auto { margin-left: auto; margin-right: auto; }
        .p-2 { padding: 0.5rem; }
        .p-3 { padding: 0.75rem; }
        .p-4 { padding: 1rem; }
        .p-6 { padding: 1.5rem; }
        .px-4 { padding-left: 1rem; padding-right: 1rem; }
        .py-2 { padding-top: 0.5rem; padding-bottom: 0.5rem; }
        .py-3 { padding-top: 0.75rem; padding-bottom: 0.75rem; }
        .border { border-width: 1px; border-style: solid; border-color: var(--border-color); }
        .border-accent { border-color: var(--accent-primary); }
        .rounded-sm { border-radius: var(--border-radius-sm); }
        .rounded-md { border-radius: var(--border-radius-md); }
        .rounded-lg { border-radius: var(--border-radius-lg); }
        .rounded-full { border-radius: var(--border-radius-full); }
        .shadow-md { box-shadow: var(--shadow-md); }
        .shadow-lg { box-shadow: var(--shadow-lg); }
        .resize-none { resize: none; }
        .min-h-\[150px\] { min-height: 150px; }
        .transition-all { transition-property: all; transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1); transition-duration: 200ms; }
        .focus\:ring { outline: 2px solid transparent; outline-offset: 2px; box-shadow: 0 0 0 3px var(--accent-primary-light); }
        .flex { display: flex; }
        .flex-col { flex-direction: column; }
        .items-center { align-items: center; }
        .justify-center { justify-content: center; }
        .flex-grow { flex-grow: 1; }
        .relative { position: relative; }
        .absolute { position: absolute; }
        .top-full { top: 100%; }
        .right-0 { right: 0; }
        .z-10 { z-index: 10; }
        .list-disc { list-style-type: disc; }
        .list-inside { list-style-position: inside; }
        .whitespace-pre-wrap { white-space: pre-wrap; }
        .opacity-50 { opacity: 0.5; }
        .cursor-pointer { cursor: pointer; }
        .cursor-not-allowed { cursor: not-allowed; }
        .min-h-screen { min-height: 100vh; }
        .h-6 { height: 1.5rem; }
        .w-6 { width: 1.5rem; }
        .h-3 { height: 0.75rem; }

        /* --- Component Specific Styles --- */

        /* Text Area */
        .custom-textarea {
            background-color: var(--bg-secondary);
            border: 1px solid var(--border-color);
            color: var(--text-primary);
            border-radius: var(--border-radius-md);
            padding: 0.75rem;
            min-height: 150px;
            transition: border-color 0.2s ease-in-out, box-shadow 0.2s ease-in-out;
        }
        .custom-textarea:focus {
            outline: none;
            border-color: var(--accent-primary);
            box-shadow: 0 0 0 3px rgba(168, 85, 247, 0.4); /* Purple focus ring */
        }
        .custom-textarea::placeholder {
            color: var(--text-muted);
        }

        /* Progress Bar */
        .progress-container {
            background-color: var(--bg-tertiary);
            border-radius: var(--border-radius-full);
            overflow: hidden;
        }
        .progress-bar {
            background-color: var(--accent-primary);
            height: 100%;
            border-radius: var(--border-radius-full);
            transition: width 0.4s ease;
        }

        /* Button */
        .custom-button {
            background-color: var(--accent-primary);
            color: var(--bg-primary);
            border: 2px solid transparent;
            padding: 0.75rem 1.5rem;
            border-radius: var(--border-radius-lg);
            font-weight: 600;
            transition: all 0.2s ease-in-out;
            box-shadow: var(--shadow-sm);
            cursor: pointer;
        }
        .custom-button:hover:not(:disabled) {
            background-color: var(--accent-primary-light);
            box-shadow: var(--shadow-md);
            transform: translateY(-1px);
        }
        .custom-button:focus {
            outline: none;
            box-shadow: 0 0 0 4px rgba(168, 85, 247, 0.4); /* Purple Focus ring */
        }
        .custom-button:active:not(:disabled) {
            background-color: var(--accent-primary-dark);
            transform: translateY(0px);
            box-shadow: var(--shadow-sm);
        }
        .custom-button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            box-shadow: none;
        }

        /* Info Icon & Tooltip */
        .info-icon {
            color: var(--text-muted);
            transition: color 0.2s ease;
        }
        .info-icon:hover {
            color: var(--text-primary);
        }
        .tooltip {
            background-color: var(--bg-secondary);
            border: 1px solid var(--border-color);
            color: var(--text-secondary);
            border-radius: var(--border-radius-md);
            box-shadow: var(--shadow-lg);
            width: 20rem; /* Increased width slightly */
            padding: 0.75rem; /* p-3 */
            margin-top: 0.5rem; /* mt-2 */
        }
        .tooltip p, .tooltip ul {
            margin-bottom: 0.5rem;
        }
        .tooltip ul {
            padding-left: 1.25rem; /* Indent list */
        }
        .tooltip li {
            margin-bottom: 0.25rem;
        }

        /* Error Message */
        .error-message {
            background-color: var(--error-bg);
            border: 1px solid var(--error-border);
            color: var(--error-text);
            border-radius: var(--border-radius-md);
            padding: 0.75rem; /* p-3 */
            margin-top: 1rem; /* mt-4 */
            max-width: 28rem; /* max-w-md */
            width: 100%;
            white-space: pre-wrap;
            font-size: 0.875rem; /* text-sm */
        }
        .error-message strong {
            color: var(--text-primary); /* Make "Error:" stand out more */
        }

        /* Success Message */
        .success-message {
            background-color: var(--success-bg);
            border: 1px solid var(--success-border);
            color: var(--success-text);
            border-radius: var(--border-radius-md);
            padding: 0.75rem; /* p-3 */
            margin-top: 1rem; /* mt-4 */
            max-w-28rem; /* max-w-md */
            width: 100%;
            white-space: pre-wrap;
            font-size: 0.875rem; /* text-sm */
        }

        /* Separator */
        .separator {
            border-color: var(--bg-tertiary); /* Subtle separator */
        }

    </style>
</head>
<body class="bg-primary">
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useRef, useEffect } = React;
        const { createRoot } = ReactDOM;

        const MTGProxyGenerator = () => {
            // --- State and Refs ---
            const [showInfoDiv, setShowInfoDiv] = useState(false);
            const timeoutRef = useRef(null);
            const textAreaRef = useRef(null);
            const progressBarRef = useRef(null);
            const progressPercentageRef = useRef(null);
            const [isGenerating, setIsGenerating] = useState(false);
            const [generationError, setGenerationError] = useState(null);
            const [pdfBuildNotification, setPdfBuildNotification] = useState(false);

            // --- Effects ---
            useEffect(() => {
                return () => {
                    if (timeoutRef.current) {
                        clearTimeout(timeoutRef.current);
                    }
                };
            }, []);

            // --- Event Handlers ---
            const handleInfoMouseEnter = () => {
                if (timeoutRef.current) clearTimeout(timeoutRef.current);
                timeoutRef.current = setTimeout(() => {
                    setShowInfoDiv(true);
                }, 200);
            };

            const handleInfoMouseLeave = () => {
                if (timeoutRef.current) clearTimeout(timeoutRef.current);
                setShowInfoDiv(false);
            };

            // --- Helper Functions ---

            // Helper to get image URIs from Scryfall data (handles single and double faced)
            const getImageUris = (data) => {
                const uris = [];
                if (data?.card_faces) {
                     data.card_faces.forEach(face => {
                        if(face?.image_uris?.png) uris.push(face.image_uris.png);
                        else if(face?.image_uris?.large) uris.push(face.image_uris.large);
                        else if(face?.image_uris?.normal) uris.push(face.image_uris.normal);
                    });
                } else {
                    if (data?.image_uris?.png) uris.push(data.image_uris.png);
                    else if (data?.image_uris?.large) uris.push(data.image_uris.large);
                    else if (data?.image_uris?.normal) uris.push(data.image_uris.normal);
                }
                return uris.filter(url => url !== undefined); // Remove undefineds
            };

            // Fetch card image URL(s) from Scryfall API
            const fetchCardImage = async (cardName, setCode = null, collectorNumber = null) => {
                let specificPrintFailed = false; // Flag to track if specific print fetch failed

                // 1. Try Specific Print if specified
                if (setCode && collectorNumber) {
                    const specificUrl = `https://api.scryfall.com/cards/${encodeURIComponent(setCode)}/${encodeURIComponent(collectorNumber)}`;
                    try {
                        console.log(`Attempting fetch for specific print: ${cardName} (${setCode}, ${collectorNumber}) at ${specificUrl}`);
                        const response = await fetch(specificUrl);
                        if (!response.ok) {
                             throw new Error(`Scryfall API error: ${response.status} (${response.statusText}) for ${setCode}/${collectorNumber}`);
                        }
                        const data = await response.json();
                        const uris = getImageUris(data);
                        if (uris.length > 0) {
                            console.log(`Found specific print: ${data.name} (${data.set}, ${data.collector_number})`);
                            return uris;
                        }
                         throw new Error(`No suitable image found for specific print ${setCode}/${collectorNumber}`);
                    } catch (error) {
                        console.warn(`Specific print fetch failed for "${cardName} (${setCode}, ${collectorNumber})":`, error.message);
                        specificPrintFailed = true; // Mark failure and fall through to name search
                    }
                }

                // 2. Handle "Random" keyword
                if (cardName.toLowerCase() === 'random') {
                    const randomUrl = 'https://api.scryfall.com/cards/random';
                    try {
                        const response = await fetch(randomUrl);
                        if (!response.ok) {
                            throw new Error(`Scryfall API error: ${response.status} (Random)`);
                        }
                        const data = await response.json();
                        const uris = getImageUris(data);
                         if (uris.length > 0) return uris;
                        throw new Error(`No suitable image found for random card`);
                    } catch (error) {
                        console.error(`Error fetching random card:`, error);
                        throw new Error(`Failed to fetch random card: ${error.message}`);
                    }
                }

                // 3. Try Exact Name Match
                const exactUrl = `https://api.scryfall.com/cards/named?exact=${encodeURIComponent(cardName)}`;
                try {
                    console.log(`Attempting exact match for: "${cardName}" at ${exactUrl}`);
                    const response = await fetch(exactUrl);
                    if (response.ok) {
                        const data = await response.json();
                         const uris = getImageUris(data);
                         if (uris.length > 0) {
                             if (specificPrintFailed) {
                                 // Add a note if we fell back from a specific print failure
                                 return { uris, fallbackNote: `Specific print not found, using default "${data.name}".` };
                             }
                             return uris;
                         }
                        // Continue to fuzzy if exact found but no image
                    } else if (response.status !== 404) { // Only throw non-404 errors
                         throw new Error(`Scryfall API error: ${response.status} (Exact) for "${cardName}"`);
                    }
                } catch (error) {
                    console.warn(`Exact match attempt failed for "${cardName}":`, error.message);
                    // Don't throw yet, try fuzzy
                }

                // 4. Try Fuzzy Name Match
                const fuzzyUrl = `https://api.scryfall.com/cards/named?fuzzy=${encodeURIComponent(cardName)}`;
                try {
                    console.log(`Attempting fuzzy match for: "${cardName}" at ${fuzzyUrl}`);
                    const response = await fetch(fuzzyUrl);
                     if (!response.ok) {
                         // If fuzzy also fails, throw the error
                         throw new Error(`Scryfall API error: ${response.status} (Fuzzy) for "${cardName}"`);
                     }
                    const data = await response.json();
                    const uris = getImageUris(data);
                    if (uris.length > 0) {
                        if (specificPrintFailed) {
                            return { uris, fallbackNote: `Specific print not found, using fuzzy match "${data.name}".` };
                        }
                         return uris;
                    }
                    // If fuzzy found but no image
                    throw new Error(`No suitable image found for card (fuzzy match: ${data?.name || cardName})`);

                } catch (error) {
                     console.error(`Error fetching card image for "${cardName}":`, error);
                     // Re-throw a cleaned-up error message
                     const baseMessage = specificPrintFailed ? `Specific print request failed, and name search also failed for "${cardName}"` : `Failed to find card "${cardName}"`;
                     throw new Error(`${baseMessage}: ${error.message.includes('Scryfall API error') ? error.message : 'Not found or image unavailable.'}`);
                }
            };

            // --- PDF Generation ---
            const handleGenerate = async () => {
                if (!textAreaRef.current) return;

                const rawLines = textAreaRef.current.value
                    .split('\n')
                    .map(line => line.trim())
                    .filter(line => line !== '');

                if (rawLines.length === 0) {
                    setGenerationError("Please enter at least one card name.");
                    return;
                }

                setIsGenerating(true);
                setGenerationError(null);
                setPdfBuildNotification(false);
                let processedLines = 0;
                const totalLines = rawLines.length;

                // Reset progress bar
                if (progressBarRef.current && progressPercentageRef.current) {
                    progressBarRef.current.style.width = '0%';
                    progressPercentageRef.current.textContent = '0%';
                }

                const loadJsPDF = () => new Promise((resolve, reject) => {
                    if (typeof window === 'undefined') return reject(new Error('Not in browser'));
                    if (typeof window.jspdf?.jsPDF !== 'undefined') return resolve(window.jspdf.jsPDF);
                    const script = document.createElement('script');
                    script.src = 'https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js';
                    script.async = true;
                    script.onload = () => typeof window.jspdf?.jsPDF !== 'undefined' ? resolve(window.jspdf.jsPDF) : reject(new Error('jsPDF loaded but constructor not found.'));
                    script.onerror = () => reject(new Error('Failed to load jsPDF script.'));
                    document.head.appendChild(script);
                });

                try {
                    const cardFetchPromises = [];
                    const errors = [];
                    const warnings = []; // For non-fatal issues like fallback prints

                    // 1. Parse Input and Initiate Fetches
                    for (const line of rawLines) {
                        let inputLine = line;
                        let cardName = line;
                        let quantity = 1;
                        let setCode = null;
                        let collectorNumber = null;

                        // Check for specific print format: Card Name (SET, NUM)
                        const printMatch = line.match(/^(.*?)\s*\(([^,]+),\s*([^)]+)\)\s*$/);
                        if (printMatch) {
                            cardName = printMatch[1].trim();
                            setCode = printMatch[2].trim().toLowerCase(); // Scryfall uses lowercase set codes
                            collectorNumber = printMatch[3].trim();
                            inputLine = cardName; // Use the base name for quantity parsing now
                        }

                        // Check for quantity: [num] [name] or [name] [x][num]
                        const quantityMatch = inputLine.match(/^(?:(\d+)\s*x?\s*(.+?)|(.+?)\s*x?(\d+))$/i);
                        if (quantityMatch) {
                            quantity = parseInt(quantityMatch[1] || quantityMatch[4], 10);
                            cardName = (quantityMatch[2] || quantityMatch[3]).trim();
                        } else {
                            cardName = inputLine.trim(); // Use the (potentially modified) name if no quantity found
                        }

                        if (isNaN(quantity) || quantity < 1) quantity = 1;

                        // Add fetch promise
                        cardFetchPromises.push(
                            fetchCardImage(cardName, setCode, collectorNumber)
                                .then(result => {
                                    let uris;
                                    let fallbackNote = null;
                                    // Check if result is an object with uris and fallbackNote
                                    if (typeof result === 'object' && result !== null && Array.isArray(result.uris)) {
                                        uris = result.uris;
                                        fallbackNote = result.fallbackNote;
                                    } else if (Array.isArray(result)) {
                                        uris = result; // It's just an array of URIs
                                    } else {
                                        throw new Error("Invalid result format from fetchCardImage");
                                    }

                                    if (fallbackNote) {
                                        warnings.push(fallbackNote);
                                    }
                                    return uris.map(url => ({ url, quantity, originalInput: line }));
                                })
                                .catch(error => {
                                    errors.push(`Error for "${line}": ${error.message}`);
                                    return []; // Return empty array on error for this line
                                })
                                .finally(() => {
                                    processedLines++;
                                    if (progressBarRef.current && progressPercentageRef.current) {
                                        const percentage = Math.round((processedLines / totalLines) * 100);
                                        progressBarRef.current.style.width = `${percentage}%`;
                                        progressPercentageRef.current.textContent = `${percentage}%`;
                                    }
                                })
                        );
                    } // End parsing loop

                    // 2. Await all fetches and collect results
                    const results = await Promise.all(cardFetchPromises);
                    const cardData = results.flat(); // Flatten the array of arrays

                    if (cardData.length === 0 && errors.length > 0) {
                         setGenerationError(`No card images could be fetched.\n${errors.join('\n')}`);
                         setIsGenerating(false);
                         return;
                    }
                    if (cardData.length === 0 && errors.length === 0) {
                         setGenerationError("No valid card inputs found or processed.");
                         setIsGenerating(false);
                         return;
                    }


                    // Set notification
                    setPdfBuildNotification(true);

                    // 3. Load jsPDF and initialize document
                    const jsPDF = await loadJsPDF();
                    const doc = new jsPDF({ orientation: 'portrait', unit: 'in', format: 'letter' });

                    // --- PDF Layout Constants ---
                    const mmToIn = (mm) => mm / 25.4;
                    const cardWidthIn = 2.5;
                    const cardHeightIn = 3.5;
                    const cardsPerRow = 3;
                    const cardsPerCol = 3;
                    const totalCardsPerPage = cardsPerRow * cardsPerCol;
                    const pageW = doc.internal.pageSize.getWidth(); // 8.5 in
                    const pageH = doc.internal.pageSize.getHeight(); // 11 in
                    const marginIn = mmToIn(3); // ~0.12 in
                    const gapIn = mmToIn(3);     // ~0.12 in
                    const requiredWidth = marginIn * 2 + cardsPerRow * cardWidthIn + (cardsPerRow - 1) * gapIn;
                    const requiredHeight = marginIn * 2 + cardsPerCol * cardHeightIn + (cardsPerCol - 1) * gapIn;

                    if (requiredWidth > pageW || requiredHeight > pageH) {
                        console.warn("Calculated layout might exceed page size. Consider smaller margins/gaps or fewer cards per page.");
                        errors.push("Warning: Card layout might slightly exceed page boundaries.");
                    }

                    let currentX = marginIn;
                    let currentY = marginIn;
                    let cardsOnCurrentPage = 0;
                    let totalCardsAddedToPdf = 0;

                    // 4. Add Images to PDF
                    for (const card of cardData) {
                         for (let j = 0; j < card.quantity; j++) {
                            if (cardsOnCurrentPage >= totalCardsPerPage) {
                                doc.addPage();
                                currentX = marginIn;
                                currentY = marginIn;
                                cardsOnCurrentPage = 0;
                            }

                            try {
                                const imageResponse = await fetch(card.url); // Fetch image data
                                if (!imageResponse.ok) throw new Error(`HTTP ${imageResponse.status} fetching image`);
                                const imageBlob = await imageResponse.blob();
                                const imageDataUrl = await new Promise((resolve, reject) => {
                                    const reader = new FileReader();
                                    reader.onloadend = () => resolve(reader.result);
                                    reader.onerror = reject;
                                    reader.readAsDataURL(imageBlob);
                                });
                                const imageType = imageBlob.type.split('/')[1]?.toUpperCase() || (card.url.toUpperCase().includes('PNG') ? 'PNG' : 'JPEG'); // Determine type

                                doc.addImage(imageDataUrl, imageType, currentX, currentY, cardWidthIn, cardHeightIn);
                                cardsOnCurrentPage++;
                                totalCardsAddedToPdf++;

                                // Move to next position
                                currentX += cardWidthIn + gapIn;
                                if (cardsOnCurrentPage % cardsPerRow === 0) {
                                    currentX = marginIn;
                                    currentY += cardHeightIn + gapIn;
                                }
                             } catch (error) {
                                console.error(`Error adding image ${card.url} (from input "${card.originalInput}") to PDF:`, error);
                                errors.push(`Error adding image for ${card.originalInput}: ${error.message}`);
                            }
                        }
                    }

                    // 5. Finalize and Save
                    let finalMessage = "";
                    if(warnings.length > 0){
                        finalMessage += `Notes:\n${warnings.join('\n')}\n\n`;
                    }
                     if (errors.length > 0) {
                         finalMessage += `PDF generated with ${totalCardsAddedToPdf} cards, but encountered issues:\n${errors.join('\n')}`;
                         setGenerationError(finalMessage); // Set as error if issues occurred
                    } else if (warnings.length > 0) {
                        setGenerationError(finalMessage); // Show warnings even if no fatal errors
                    }


                    if (totalCardsAddedToPdf > 0) {
                        doc.save('mtg-proxies.pdf');
                    } else if (errors.length === 0 && warnings.length === 0) { // Only show this if no other messages
                        setGenerationError("No cards were ultimately added to the PDF. Please check your input list and potential errors above.");
                    }

                } catch (error) {
                    console.error("Fatal PDF Generation Error:", error);
                    setGenerationError(`Fatal Error: ${error.message || "An unexpected error occurred during PDF generation."}`);
                } finally {
                    setIsGenerating(false);
                    setPdfBuildNotification(false);
                }
            }; // End handleGenerate

            // --- Render JSX ---
            return (
                <div className="min-h-screen bg-primary flex flex-col items-center p-4 md:p-6 font-sans w-full">
                    <div className="w-full max-w-2xl mx-auto flex flex-col items-center">

                        <h1 className="text-2xl font-semibold text-primary mb-6 mt-4">
                            MTG Proxy Generator
                        </h1>

                        <textarea
                            className="w-full max-w-md custom-textarea mb-4 resize-none"
                            placeholder="Enter card names, one per line...
Examples:
4 Sol Ring
Island x8
Ragavan, Nimble Pilferer
Black Lotus (Vintage Campionship, 2017NA)"
                            ref={textAreaRef}
                            disabled={isGenerating}
                            rows="8"
                        />

                        <div className="w-full max-w-md flex items-center mb-4 px-1">
                            <div className="progress-container flex-grow h-3 mr-2">
                                <div
                                    className="progress-bar"
                                    style={{ width: '0%' }}
                                    ref={progressBarRef}
                                />
                            </div>
                            <span className="text-secondary text-sm font-medium" ref={progressPercentageRef}>
                                0%
                            </span>
                        </div>

                         {pdfBuildNotification && (
                            <div className="success-message">
                                Building the PDF, this might take a while for many cards...
                            </div>
                        )}

                        <hr className="w-full max-w-md separator mb-6" />

                        <div className="w-full max-w-md flex items-center justify-center mb-6">
                            <button
                                className="custom-button mr-2"
                                onClick={handleGenerate}
                                disabled={isGenerating}
                            >
                                {isGenerating ? 'Generating...' : 'Generate Proxies'}
                            </button>

                            <div
                                className="relative cursor-pointer ml-2"
                                onMouseEnter={handleInfoMouseEnter}
                                onMouseLeave={handleInfoMouseLeave}
                            >
                                <svg xmlns="http://www.w3.org/2000/svg" className="h-6 w-6 info-icon" fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth={2}>
                                    <path strokeLinecap="round" strokeLinejoinm="round" d="M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
                                </svg>
                                {showInfoDiv && (
                                    <div className="absolute tooltip z-10" style={{ top: '100%', right: 0 }}>
                                        <p className="font-semibold text-primary mb-1">Input Format:</p>
                                        <p className="mb-2">
                                            Enter one card per line. Specify quantities like "4 Card Name", "Card Name x4", or "Card Name 4".
                                            Use "Random" for a random card. Fuzzy matching used if exact name fails.
                                        </p>
                                         <p className="font-semibold text-primary mb-1">Specify Print:</p>
                                        <p className="mb-2">
                                            Add Set name and Collector Number in parentheses: `Card Name (SET, NUM)`. you can find these in each card's page on <a href="https://scryfall.com">Scryfall</a>
                                        </p>
                                        <p className="font-semibold text-primary mb-1">Examples:</p>
                                        <ul className="list-disc list-inside">
                                            <li>Black Lotus</li>
                                            <li>4 Sol Ring</li>
                                            <li>Mountain x8</li>
                                            <li>Island 6</li>
                                            <li>Ragavan // Nimble Pilferer</li>
                                            <li>Black Lotus (Vintage Campionship, 2017NA)</li>
                                            <li>Random x5</li>
                                        </ul>
                                    </div>
                                )}
                            </div>
                        </div>

                         {generationError && (
                            <div className="error-message"> {/* Use class for consistent styling */}
                                {/* Check if the message contains "Error:" or "Notes:" prefix already */}
                                {!(generationError.startsWith("Error:") || generationError.startsWith("Notes:")) && <strong>Error:</strong>}
                                <br/>
                                {generationError}
                            </div>
                        )}
                    </div>
                </div>
            );
        }; // End of MTGProxyGenerator component

        // --- React App Initialization ---
        const rootElement = document.getElementById('root');
        const root = createRoot(rootElement);
        root.render(<MTGProxyGenerator />);

    </script>
</body>
</html>
